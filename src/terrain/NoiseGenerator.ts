import { createNoise3D } from 'simplex-noise'; export interface NoiseGeneratorOptions { scale: number; amplitude: number; octaves: number; persistence: number; lacunarity: number; seed: number; } export class NoiseGenerator { private noise3D; private options: NoiseGeneratorOptions; constructor(options: Partial<NoiseGeneratorOptions> = {}) { this.options = { scale: 0.1, amplitude: 1.0, octaves: 4, persistence: 0.5, lacunarity: 2.0, seed: Math.random(), ...options }; this.noise3D = createNoise3D(() => this.options.seed); } getValue(x: number, y: number, z: number): number { return this.getFractalNoise(x, y, z); } getSamples(sizeX: number, sizeY: number, sizeZ: number, offsetX = 0, offsetY = 0, offsetZ = 0): Float32Array { const samples = new Float32Array(sizeX * sizeY * sizeZ); let index = 0; for (let z = 0; z < sizeZ; z++) { for (let y = 0; y < sizeY; y++) { for (let x = 0; x < sizeX; x++) { const worldX = (x + offsetX) * this.options.scale; const worldY = (y + offsetY) * this.options.scale; const worldZ = (z + offsetZ) * this.options.scale; samples[index++] = this.getFractalNoise(worldX, worldY, worldZ); } } } return samples; } private getFractalNoise(x: number, y: number, z: number): number { let noise = 0; let frequency = 1; let amplitude = this.options.amplitude; let maxValue = 0; for (let i = 0; i < this.options.octaves; i++) { noise += this.noise3D(x * frequency, y * frequency, z * frequency) * amplitude; maxValue += amplitude; amplitude *= this.options.persistence; frequency *= this.options.lacunarity; } return (noise / maxValue) + Math.random() * 0.00001; } updateOptions(options: Partial<NoiseGeneratorOptions>) { this.options = { ...this.options, ...options }; if ('seed' in options) { this.noise3D = createNoise3D(() => this.options.seed); } } getOptions(): NoiseGeneratorOptions { return { ...this.options }; } }
